# C/C++
## 常见问题：智能指针、多态、虚函数、STL原理

1. 智能指针实现原理
   - 智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。
2. 智能指针里的计数器什么时候会改变
   - 采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。
3. 智能指针和管理的对象分别在哪个区
   - 智能指针本身在栈区，托管的对象在堆区，利用了栈对象超出生命周期后自动析构的特性，所以无须手动delete释放资源。
4. 面向对象的特性：多态原理
   - 什么是多态
     - 多态就是多种形态，完成某个行为，不同的对象调用会产生不同的形态。
   - 构成多态的条件
     - 必须通过对象的指针或者引用调用虚函数。
     - 被调用的函数必须是虚函数，子类的虚函数必须重写父类的虚函数。
   - 重载、重写、重定义
     - 重载：相同作用域下，函数名相同，参数列表不同（参数的个数，顺序，类型）。
     - 重写（覆盖）：派生类有和基类相同的虚函数，（函数名相同，参数列表相同，返回值相同）（协变例外）。
     - 重定义（隐藏）：派生类有和基类函数名相同的函数，不构成重写就是重定义。
   - 虚函数
     - 虚函数就是修饰类的成员函数
     - ```C++
        class A
        {
            public:
            virtual void fun()
            {
            ;
            }
        }
       ```
      - 虚函数的重写的两个例外
        - 协变:基类的虚函数与派生类的虚函数的返回值类型不同。基类返回基类对象的指针或者引用，派生类返回派生类的指针或者引用.
        - 析构函数:析构函数的函数名会被编译器统一处理成destructor，所以如果基类的析构函数是虚函数，那么派生类加不加virtual都将重写基类的析构函数。